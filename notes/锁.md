## 锁

通常我们为了保证线程安全，我们会使用锁进行控制。Java 中的锁可以分为“同步锁”和“并发包中的锁”

#### 同步锁

通过 synchronized 关键字来进行同步，实现对竞争资源的互斥访问的锁。

其原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。

#### 并发包中的锁

更加强大也更加复杂的锁框架

##### AQS (AbstractQueuedSynchronizer)

该类是锁框架的基础，其本质是一个同步器，作为锁框架的基础，承担着获取锁和释放锁的操作。其获取和释放锁是通过修改状态位来实现，AQS 有以下几个功能：
- 原子操作状态位（32位整数来描述状态位）
- 阻塞和唤醒指定线程（通过 LockSupport 实现）
- 维护一个有序队列（基于 CLH 的 FIFO 队列）

> [Doug Lea 的 AQS 论文](http://gee.cs.oswego.edu/dl/papers/aqs.pdf)

##### 公平锁 ( FairSync ) 和 非公平锁 ( NonfairSync )

- 公平锁：保证一个阻塞的线程最终能够获得锁，因为在有序队列中总是可以按照顺序获得锁
- 不公平锁：当前线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能
    > 因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。因此非公平锁就可以利用这段时间完成操作。这是非公平锁在某些时候比公平锁性能要好的原因之一。
    > 原理：当前线程首先 compareAndSetState ，不成功的话再进入队列

##### Condition

Condition 的作用是对锁进行更精确的控制，对于同一个锁，我们可以创建多个 Condition，在不同的情况下使用不同的 Condition。
Condition 中的 await() 方法相当于 Object 的 wait() 方法，Condition 中的 signal() 方法相当于 Object 的 notify() 方法，Condition 中的 signalAll() 相当于 Object 的 notifyAll() 方法。不同的是，Object 中的 wait(),notify(),notifyAll() 方法是和"同步锁"(synchronized关键字)捆绑使用的；而 Condition 是需要与"互斥锁"/"共享锁"捆绑使用的。


##### ReentrantLock

可重入的互斥锁,独占锁

##### ReentrantReadWriteLock

- “读取锁”用于只读操作，它是“共享锁”，能同时被多个线程获取。
- “写入锁”用于写入操作，它是“独占锁”，写入锁只能被一个线程锁获取。
- 不能同时存在读取锁和写入锁！
- 锁降级：写线程获取写入锁后可以再次获取读取锁，但是读线程获取读取锁后却不能获取写入锁。

##### StampedLock

Java8中对读写锁的改进版本，ReentrantReadWriteLock 在读操作远远大于写操作时有可能造成写操作的饥饿问题（读操作一直抢占 CPU 时间片），所以 StampedLock 解决了这个问题，使读操作不会阻塞写操作。


##### 闭锁（CountDownLatch）

允许一个或者多个线程等待某个事件的发生。CountDownLatch 基于共享锁的实现，维护了一个正数计数器，countDown 方法对计数器做减操作，await 方法等待计数器达到0。所有 await 的线程都会阻塞直到计数器为0或者等待线程中断或者超时。

##### 屏障锁（CyclicBarrier）

允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。

##### 信号量（Semaphore）

信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。

#### 怎么减少锁竞争

- 减少锁持有的时间
- 减少锁请求的频率
- 采用共享锁取代独占锁

#### 死锁

- 锁无法释放
- 非公平锁中某些线程总是拿到锁，活跃度低的线程就会拿不到锁，出现“饥饿死锁”

