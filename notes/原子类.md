## 原子类

简单的、高效的、线程安全的递增递减方案，其中大量使用循环 CAS 自旋操作，效率比加锁高很多。

1. 基本类型:
    - AtomicInteger
    - AtomicLong
    - AtomicBoolean

2. 数组类型:
    - AtomicIntegerArray
    - AtomicLongArray
    - AtomicReferenceArray

3. 引用类型:
    - AtomicReference
    - AtomicStampedReference（<Object,int>结构）
    - AtomicMarkableReference （<Object,Boolean>结构）

4. 对象的属性修改类型:
    - AtomicIntegerFieldUpdater
    - AtomicLongFieldUpdater
    - AtomicReferenceFieldUpdater
> 1. 字段必须是volatile类型的，不能是 final 类型的
> 2. 有权限修改（修饰符public/protected/default/private）
> 3. 只能是实例变量，不能是类变量（static）
> 4. 包装类只能用 AtomicReferenceFieldUpdater

##### 什么是原子操作
多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。

##### CAS 自旋
synchronized 悲观锁，它会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。
而CAS 自旋锁就是乐观锁。它每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
整个 Java 并发包都是建立在 CAS 之上，现代 CPU 提供了 CAS 指令，使这个操作非常快。
CAS 其实还是会带来“ABA”问题，虽然值没有问题，但不代表这个过程中没有发生任何变化。

##### 锁（挂起线程）与 CAS（自旋） 取舍
在轻度到中度的争用情况下，非阻塞算法的性能会超越阻塞算法，因为 CAS 的多数时间都在第一次尝试时就成功，而发生争用时的开销也不涉及线程挂起和上下文切换，只多了几个循环迭代。没有争用的 CAS 要比没有争用的锁便宜得多（这句话肯定是真的，因为没有争用的锁涉及 CAS 加上额外的处理），而争用的 CAS 比争用的锁获取涉及更短的延迟。

在高度争用的情况下（即有多个线程不断争用一个内存位置的时候），基于锁的算法开始提供比非阻塞算法更好的吞吐率，因为当线程阻塞时，它就会停止争用，耐心地等候轮到自己，从而避免了进一步争用。但是，这么高的争用程度并不常见，因为多数时候，线程会把线程本地的计算与争用共享数据的操作分开，从而给其他线程使用共享数据的机会。（这么高的争用程度也表明需要重新检查算法，朝着更少共享数据的方向努力。）

挂起一个线程可能是因为无法获取到锁，或者需要某个特定的条件，或者耗时的I/O操作。挂起一个线程需要两次额外的上下文切换以及操作系统、缓存等多资源的配合：如果线程被提前换出，那么一旦拿到锁或者条件满足，那么又需要将线程换回执行队列，这对线程而言，两次上下文切换可能比较耗时。

总结：**自旋适合于比较短的等待，而挂起线程适合那些比较耗时的等待。**

