## 并发容器

##### CopyOnWriteArrayList

- 相当于线程安全的 ArrayList ,避免了 ConcurrentModificationException 异常(它不是fail-fast机制)
- 原理：volatile 数组、 互斥锁 和 数组的拷贝
- 可变操作会复制整个数组，开销很大
- 迭代器依赖于不变的数组快照
- 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作。
- 适用于：List 保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。

##### CopyOnWriteArraySet

- 相当于线程安全的 HashSet，HashSet 是通过 HashMap 实现的，而 CopyOnWriteArraySet 则是通过 CopyOnWriteArrayList 实现
- 和 CopyOnWriteArrayList 一样，可变操作开销大，迭代器器依赖于不变的数组快照，迭代器只支持不可变操作。
- 适用于：Set 保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。

##### ConcurrentHashMap

- 相当于线程安全的 HashMap，高性能的 Hashtable
- 原理：Segment（继承于ReentrantLock类）锁分段，多线程对同一个片段的访问，是互斥的；对于不同片段的访问，可以同步进行。

##### ConcurrentSkipListMap

- 相当于线程安全的 TreeMap，不同的是 ConcurrentSkipListMap 是通过跳表实现的，而 TreeMap 是通过红黑树实现的。

##### ConcurrentSkipListSet

- 相当于线程安全的 TreeSet,不同的是 ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，而 TreeSet 是通过 TreeMap 实现的。

##### ArrayBlockingQueue

- 数组实现的线程安全的有界的阻塞队列。
-

