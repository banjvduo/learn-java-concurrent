## Java Thread

##### 线程的五种状态

- 新建状态 new
- 就绪状态 start
- 运行状态
- 阻塞状态
  - 等待阻塞 wait( )
  - 同步阻塞 synchronized
  - 其它阻塞 sleep( ) join( ) 或 发生 I/O
- 死亡状态 执行完毕或异常退出


##### 实现多线程的方式

- 继承 Thread
- 实现 Runnable

> 由于 Java 的单继承多实现规则，实现 Runnable 接口，对程序有更高的扩展性；
> Runnable 实现的多线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。


##### 多线程的启动

- start( )
    > 启动一个新的线程来执行 run( ),调用 start( )方法后该线程变为就绪状态，随时可以被 CPU 调度执行
- run( )
    > 在当前线程执行 run( ),并不会启动新的线程

##### synchronized 关键字


- 每个对象只有一个同步锁，同步锁依赖于对象而存在
- 不同线程对同步锁的访问是互斥的
- synchronized 修饰方法，如果当前类不是单例的，那么是实例锁
- static synchronized 修饰方法，是全局锁

##### 线程的等待与唤醒

- wait( ) 使当前线程等待（和 this 无关），并释放当前线程持有的锁，被唤醒后是就绪状态
- notify( ) 和 notifyAll( ) 唤醒此对象监视器上的线程
- 等待唤醒依赖对象的同步锁，两者应为同一个锁，等待线程被唤醒时并不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。

##### 线程的让步

- yield( ) 使当前线程由运行状态到就绪状态，但有可能立马又被调度执行(即便是其它线程拥有一样的优先级)
- yield( ) 并不会释放锁

##### 线程的休眠

- sleep( ) 使当前线程由运行状态到阻塞状态，指定时间过后变成就绪状态
- sleep( ) 并不会释放锁

##### 线程的 join( )

- 让“主线程”等待“子线程”结束之后才能继续运行（注：其实主线程结束，并不会影响子线程继续运行）
- 内部实现是 while 循环判断子线程是否 alive ，是的话就 wait 当前线程，即主线程

##### 线程的终止

- interrupt( ) 中断本线程
- 当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。
- interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。
- interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记

##### 线程优先级和守护线程

- 线程优先级的范围是1～10，默认的优先级是5。
- “高优先级线程”会优先于“低优先级线程”执行。
- 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。
- 守护线程创建的子线程才是守护线程
- 用户线程可以设置成守护线程

